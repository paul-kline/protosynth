<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>wellfounded</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library wellfounded</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Intro</h1>

  So you've run into despare.. You want to define a fixpoint (recursive) function in Coq, but instead of the beautiful green line you'd expect after defining it, you get an error message like, <tt>"Cannot guess decreasing argument of fix."</tt> What is this nonsense? 

<div class="paragraph"> </div>

  Alas, there is hope! Coq, being aware it's a terrible guesser, allows you to provide your own proof that a fixpoint function won't loop forever.

<div class="paragraph"> </div>

  Alas, there is despare. There seems to be but one resource to help you on your self defining journey-- The General Recursion chapter of Certified Programming with Dependent Types (http://adam.chlipala.net/cpdt/html/GeneralRec.html), and if you're anything like me in height it will go way over your head. I will say, however, that without this chapter I would have never figured this stuff out. As complicated as it is, it is infinitely better than just looking at the Coq libraries. I was able to get just enough from it to struggle my way through over the course of.. well a long time. I could find nowhere on the internet a step by step guide or tutorial on how to define my own fixpoint function with proof of well founded-ness--something I thought surely I was not the first person to want to do. "Whence" this blog post. 

<div class="paragraph"> </div>

  Alas, ther is hope! Below I will go through how to define the "intuitive" definition of integer division (which is non-terminating as far as Coq can tell) as an example. Perhaps you can use this as a template to define your own more complex, non-trivial well-founded recursive functions!
<a name="lab2"></a><h2 class="section">Division</h2>

  Suppose you want to define integer division in Coq--innocent enough. For the sake of simplicity, let's say dividing by zero is zero. You can prevent this of course, but for the sake of 'that's-not-what-I'm-getting-at' let's just say it's zero. You might then come up with a definition like the following ('n' stands for numerator, 'd' for denominaor):
<pre>
  Fixpoint divide (n d : nat) : nat :=
   match (n,d) with
    | (0, _) =&gt; 0
    | (_, 0) =&gt; 0
    | (_, _) =&gt; if (Nat.leb d n) 
             then S (divide (n - d) d)
             else 0
   end. 
</pre>
To which Coq replies, "Error: Cannot guess decreasing argument of fix."
        
</div>
<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

Here's what we're going to do:

<div class="paragraph"> </div>

In order to define this recursive function, we need to prove that each recursive call
is given a 'smaller' argument. Whenever you define a fixpoint and all the recursive calls are on <i>subterms</i> of the argument, Coq can figure out the function is decreasing on its own. For example,

</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <a name="f"><span class="id" title="definition">f</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="wellfounded.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> =&gt; 0<br/>
&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> =&gt; <a class="idref" href="wellfounded.html#f"><span class="id" title="definition">f</span></a> <span class="id" title="var">n'</span> <br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
is perfectly easy to define since every recursive call to <i>f</i> is given a subterm of the current argument. Thereby always getting smaller. 

<div class="paragraph"> </div>

While you and I know that our definition of divide is called on "smaller and smaller" terms, Coq's too dumb to see it. We're not recursively calling <i>divide</i> on any subterms of x or y. 

<div class="paragraph"> </div>

Don't worry! We can fix this problem on our own. Let's look at the
actual Definition of Fix so we can make one ourselves. 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Fix</span>.<br/>
</div>

<div class="doc">
<pre>
Fix
     : forall (A : Type) (R : A -&gt; A -&gt; Prop),
       well_founded R -&gt;
       forall P : A -&gt; Type,
       (forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) -&gt; forall x : A, P x
</pre>
Well that's pretty confusing. What is this well_founded thing? What is this 'R'? What is anything? Let's ignore everything else and focus on the well_founded part. For now, just know that we need to provide this well_founded <i>thing</i> so we might as well explore that first. We'll get back to what all that other messy stuff is later.

<div class="paragraph"> </div>

 Well_founded-ness is how Coq proves to itself that this function will eventually end. Thereby, making it legal in its calculus of constructive logic (no infinite regression!). It looks pretty icky because it is. Nevertheless we'll get through it piece by piece.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Let's go down the rabbit hole a little further and look at the definition of well_founded. 

<div class="paragraph"> </div>

 
</div>
<div class="code">
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#well_founded"><span class="id" title="definition">well_founded</span></a>.<br/>
</div>

<div class="doc">
<pre>
well_founded = 
fun (A : Type) (R : A -&gt; A -&gt; Prop) =&gt; forall a : A, Acc R a
     : forall A : Type, (A -&gt; A -&gt; Prop) -&gt; Prop
</pre>
The definition of well_founded is much better to look at with parens like this:
<pre>
well_founded = 
fun (A : Type) (R : A -&gt; A -&gt; Prop) =&gt; forall a : A, Acc R a
     : (forall A : Type, (A -&gt; A -&gt; Prop) ) -&gt; Prop

Argument A is implicit
</pre>
Now you can see that the big mess is just telling you what the type of <tt>Acc R a</tt> must be.

<div class="paragraph"> </div>

As an aside, remember 'Argument A is implicit' means we don't actually have to provide that argument. Coq is smart enough (for once) to figure it out from the types provided in the R relation. 

<div class="paragraph"> </div>

Ahh, the 'R' relation; I'm glad you mentioned it. The relation 'R' is a relation that is a "less than" relation. How would you know that it has to be a "less than" relation as opposed to any other and how this "less-than-ness" enforced? You wouldn't know that yet, but I do. You will soon realize that the definition of Acc forces this relation into an "is less than" shape. I keep putting "less than" in quotes because that's what makes sense to me. It's really more of a "the first argument is closer to a terminating term than the second" relation. In our case with division, we terminate when d is zero, OR when n &lt; d and we can't do integer division any further. We must prove that every subcall of divide is called with an x that is less than the one handed to the current iteration.   Only a relation that defines this monotonic decreasing behavior will be able to satisfy the constructor of Acc. It's all quite clever. 

<div class="paragraph"> </div>

Let's get back to well_founded for a minute before we move on to Acc. 
<pre>
well_founded = 
fun (A : Type) (R : A -&gt; A -&gt; Prop) =&gt; forall a : A, Acc R a
     : (forall A : Type, (A -&gt; A -&gt; Prop) ) -&gt; Prop
</pre>

<div class="paragraph"> </div>

What does well_founded say in people-speak? You try first.

<div class="paragraph"> </div>

 'well_founded' is a function that takes a relation 'R' and gives you back another function. Namely this:
 <tt>
(  forall a : A, Acc R a
     : forall A : Type, (A -&gt; A -&gt; Prop) -&gt; Prop). 
</tt>THIS function takes a proof of type: <tt>
 forall a : A, Acc R a </tt> and spits out a Prop. 
&gt;&gt;

<div class="paragraph"> </div>

'Acc' stands for 'Accessibility'.

<div class="paragraph"> </div>

Here's a really important sentence:

<div class="paragraph"> </div>

A relation 'R' over the domain 'A' is well founded IF you can prove that <i>every</i> element in 'A' is Accessible (Acc R a).

<div class="paragraph"> </div>

Okay, let's look at Acc. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a>.<br/>
</div>

<div class="doc">
<pre>
Inductive Acc (A : Type) (R : A -&gt; A -&gt; Prop) (x : A) : Prop :=
    Acc_intro : (forall y : A, R y x -&gt; Acc R y) -&gt; Acc R x
</pre>
Holy crap it's an inductive type. Finally, we are looking at something that in its definition doesn't introduce something we haven't seen before! What does Acc say in English? Give it a go, and I will too. 

<div class="paragraph"> </div>

Acc is an inductive type of type Prop.
It is 'indexed' over an 'A' which has type 'Type', a relation 'R' (which we've talked about), and a particular thing (<i>x</i>) of type A. To make an Acc there is only one constructor, 'Acc_intro' which must be provided with a proof that for any element 'y' that is "less than" x (R y x), it's 
accessible (Acc R y). If you can provide that, then x is accessible as well (Acc R x). 
And that's it! Now that we've explored all the way to the bottom of the chain we can start building our way back up to Fix.
So, let's start with 'R'. the 'A' type in R is the type of the argument that we must prove decreases.

<div class="paragraph"> </div>

Something may have been bothering you up to this point. We keep talking about "the argument" to the function being "less than" each time. What about functions that take more than one argument? Worse yet, what if you need all of those arguments to determine if you're closer to a termination term? 

<div class="paragraph"> </div>

There may be more solutions than this, but I just like to make a wrapper to hold everything I need. In our example, divide takes two naturals. So I make a wrapper for the 2 naturals into one type: 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;| <a name="mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

I may have voiced my frustration with this bookkeeping step in the naming.

<div class="paragraph"> </div>

'MyStupidPair' will play the role of 'A', the domain of our fixpoint function.

<div class="paragraph"> </div>

What is our "less than" relation? Well let's look at what our divide function would look like with this new wrapper thing:
<pre>
Fixpoint divide2 (p : MyStupidPair) : nat :=
 match p with
  | mystupidpair 0 _ =&gt; 0
  | mystupidpair _ 0 =&gt; 0
  | mystupidpair n d =&gt; S (divide2 (mystupidpair (n -d) d))
 end. 
</pre>
All we care about is that the first number 'n' is smaller each time. In whatever function you're trying to define, your "less than" relation probably depends on all the arguments, but we only care about one of ours. So our less than relation would look something like:
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="first_ltR"><span class="id" title="definition">first_ltR</span></a> (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>) : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="wellfounded.html#p1"><span class="id" title="variable">p1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="wellfounded.html#p2"><span class="id" title="variable">p2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <span class="id" title="var">n1</span> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <span class="id" title="var">n2</span> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> =&gt; <span class="id" title="var">n1</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <span class="id" title="var">n2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Looks good. Now what? Well we know for well_founded we need a proof that every element of MyStupidPair is Accessible. Let's start there.

<div class="paragraph"> </div>

Let's start with the base case.

<div class="paragraph"> </div>


</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="smallestPairAccessible"><span class="id" title="lemma">smallestPairAccessible</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">d</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> 0 <a class="idref" href="wellfounded.html#d"><span class="id" title="variable">d</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>

<div class="doc">
Cool. Let's pretend I got that proof right away. 

<div class="paragraph"> </div>

I also have a very important note to share with you that isn't relevant until later, but you see it now, so I should explain it now. I said <tt>Defined</tt> and not <tt>Qed</tt>. This is an absolute must. Remember our end goal is defining a function. This proof (and any proof that uses this proof will in one way or another be passed to Fix as an argument in the well_founded proof. When you write a theorem or whatever and end it with <tt>Qed</tt> Coq forgets about how you got to the end, and just remembers that you got there legally. We are proving things for the purpose of construction. Therefore we need Coq to 'remember' how we got there. If we leave any proof as <tt>Qed</tt> instead of <tt>Defined</tt> your final function will not reduce past (Fix_F <tt>huge-mess-of-crap</tt>) (args..). Coq can't evaluate the proofs because it has forgotten how. This also unfortunately means you can't use proofs in the standard library that end in <tt>Qed</tt>.

<div class="paragraph"> </div>

Note: You also can't use omega anywhere. This currently causes Coqtop to "die badly" when you try to use the final function. This seems like a bug and has been reported.

<div class="paragraph"> </div>

Anyway, let's prove that all elements of MyStupidPair are accessible. 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="allPairs_Acc_getStuck"><span class="id" title="lemma">allPairs_Acc_getStuck</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">p</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <a class="idref" href="wellfounded.html#p"><span class="id" title="variable">p</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="tactic">apply</span> <a class="idref" href="wellfounded.html#smallestPairAccessible"><span class="id" title="lemma">smallestPairAccessible</span></a>.<br/>
<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span> .<br/>
 <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>.<br/>
<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
I got stuck here:
<pre>
n0, n1, n2 : nat
IHn : Acc first_ltR (mystupidpair (S n1) n0)
H : first_ltR (mystupidpair (S n1) n2) (mystupidpair (S (S n1)) n0)
______________________________________(1/2)
Acc first_ltR (mystupidpair (S n1) n2)
</pre>

<div class="paragraph"> </div>

My induction hypothesis is specifically for n0, but I need it for n2! Obviously, in my relation the second number in the pair doesn't matter, but I need that proof.  

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="wellOfCourseThisisTrue"><span class="id" title="lemma">wellOfCourseThisisTrue</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="wellfounded.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="wellfounded.html#z"><span class="id" title="variable">z</span></a>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y0</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y0</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>. <span class="id" title="tactic">auto</span>.<br/>

<br/>
<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>. <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>

<div class="doc">
Let's pretend this proof I got straight away as well. (Note: <tt>Defined</tt>!)

<div class="paragraph"> </div>

Now let's try that again. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="allPairs_Acc"><span class="id" title="lemma">allPairs_Acc</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">p</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <a class="idref" href="wellfounded.html#p"><span class="id" title="variable">p</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="tactic">apply</span> <a class="idref" href="wellfounded.html#smallestPairAccessible"><span class="id" title="lemma">smallestPairAccessible</span></a>.<br/>
<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span> .<br/>
 <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>.<br/>
<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="wellfounded.html#wellOfCourseThisisTrue"><span class="id" title="lemma">wellOfCourseThisisTrue</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">z</span>:=<span class="id" title="var">n2</span>) <span class="id" title="keyword">in</span> <span class="id" title="var">IHn</span>. <span class="id" title="tactic">assumption</span> .<br/>
 <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHn</span>.<br/>
 <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As always, let's pretend I got this proof straight away. 
A word of caution however: While proving the accessibility of all elements in your domain, it is <i>really</i> easy to find yourself with an impossible proof goal. In fact, proving this all Accessible theorem is why I was stuck on well_founded-ness for so long. After I figured it out I created these steps to follow to stay on the path of righteousness. Feel free to ignore them at first and try to prove your accessibility theorem on your own. You may very well succeed, but I always got tempted to apply something that led me to an impossible proof goal and applied it. 
<pre>
  1. do induction on the thing you're proving is accessible.
  2. prove the base case.
  3. constructor. intros.  
  4. destruct on the thing that is less than the other thing. 
  5. you should have the base case to prove again or something very close to it.
  6. invert on H, the less than relation. subst. you should have that assumption.
  7. subst. destruct on your inductive hypothesis.
  8. constructor. apply your new result from inducting on hypo. auto.
</pre>

<div class="paragraph"> </div>

We pretty much have well_founded-ness for our relation now. We can start crawling out of the rabbit hole.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="pairsWfr"><span class="id" title="lemma">pairsWfr</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Wf.html#well_founded"><span class="id" title="definition">well_founded</span></a> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="wellfounded.html#allPairs_Acc"><span class="id" title="lemma">allPairs_Acc</span></a>. <span class="id" title="keyword">Defined</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

  That was nice. Now we've got what we need. Let's look at <tt>Fix</tt> again.
  
</div>
<div class="code">
<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Fix</span>.<br/>
</div>

<div class="doc">
<pre>
Fix = 
fun (A : Type) (R : A -&gt; A -&gt; Prop) (Rwf : well_founded R) (P : A -&gt; Type)
  (F : forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) (x : A) =&gt; 
Fix_F P F (Rwf x)
     : forall (A : Type) (R : A -&gt; A -&gt; Prop),
       well_founded R -&gt;
       forall P : A -&gt; Type,
       (forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) -&gt; forall x : A, P x

Arguments A, R are implicit
</pre>
Cool. Very confusing. A and R are implicit at least.  Let's look at this type with our specific example:

<div class="paragraph"> </div>

<pre>
Fix = 
fun (Rwf : well_founded first_ltR) (P : A -&gt; Type)
  (F : forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) (x : A) =&gt; 
Fix_F P F (Rwf x) : well_founded first_ltR -&gt;
       forall P : A -&gt; Type,
       (forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) -&gt; forall x : A, P x
</pre>

<div class="paragraph"> </div>

That helps a little I guess, but holy crap, it's still pretty confusing. 

<div class="paragraph"> </div>

Fix is a function that takes the well_founded proof we've been working on. It also takes this <tt>P</tt> function that's from <tt>A</tt> to <tt>Type</tt>. Why? Well I'll tell you! Coq functions can be dependently typed, remember? In our case of division, we always return something that's a <tt>nat</tt>. But that doesn't have to be the case. P is how you specify how the type of the input affects the type of the output. Our divide function is not dependently typed, so for us the P function is as simple as:
<pre>(fun _ =&gt; nat) </pre>

<div class="paragraph"> </div>

For every input, the return type is nat.

<div class="paragraph"> </div>

Cool. Next!
<pre>
(F : forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) (x : A) =&gt; 
Fix_F P F (Rwf x) : well_founded first_ltR -&gt;
       forall P : A -&gt; Type,
       (forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) -&gt; forall x : A, P x
</pre>

<div class="paragraph"> </div>

Let's ignore everything after the <tt>=&gt; </tt>. That's the type of the final fixpoint we're going to get. So let's focus on the left side of =&gt; on the stuff we need to provide. 
<pre>
(F : forall x : A, (forall y : A, R y x -&gt; P y) -&gt; P x) (x : A) =&gt; 
</pre>

<div class="paragraph"> </div>

We must give an F. 

<div class="paragraph"> </div>

F is a function whose type starts with <tt>forall x : A </tt>. For functions, this just means it accepts something of type 'A' as a parameter named 'x'. The second parameter of F is.. by golly, another function. A function of type <tt>
(forall y : A, R y x -&gt; P y)
</tt>This function takes something else of type A (named y), a proof that y is "less than" x, and gives you back the proper type according to our type function P. 

<div class="paragraph"> </div>

What's going on here? What is this second function supposed to be? Think about it first.

<div class="paragraph"> </div>

It is the recursive call. Take a look at that type again with this in mind. 
<pre>
F takes:
   1. (x : A).
   2. a function that is good for all elements "less than" x.
     (You have to provide the proof that y, the argument passed 
     to this second function is "less than" x  to use this function!
     It will look something like:
         f' (y : A) (prf : R y x) : (P y) 
     ) 
     </pre>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

That's the secret. That's the proof of termination. <i>To even use</i> the recursive function, you have to provide proof that you're calling the function on an argument closer to termination than the previous argument was.
AAAAAAAAAAAAAAND.... since you've already proven that every element is accessible (the constructor of well_founded), we've proven that it's impossible for this function to iterate forever. How? Yeah, the function is getting called on smaller and smaller things, but how do we know  it will ever end?? After all, think about real numbers. Let's say our terminating case is zero. You give me any positive real number, and I can give you a real number that's smaller than that but still not zero.

<div class="paragraph"> </div>

 <tt>
   You: 0.000000000000001
   Me : 0.0000000000000001
   
   You: 0.000000000000000000000001
   Me:  0.0000000000000000000000001
   </tt>
<div class="paragraph"> </div>

   You get the idea. We could do this all day (life). Give up. In fact, I could give you an infinite number of numbers less than yours. The point is, just because our recursive argument is getting smaller every iteration doesn't necessarily mean that it will ever reach a stopping point. 

<div class="paragraph"> </div>

   That's why we proved the accessibility of every element in our domain. We've proven that for every element in the domain A, it's accessible. And do you remember how to prove a particular element is accessible? You have to prove that all elements less than it are also accessible. This is an impossible proof for the real numbers. There is no concept of "the next" or "the previous" real number. Okay, so zero is your base case, but then what? For each real number (of which they are uncountably infinite) There are uncountably infinte proofs you must provide. The case with naturals, however, is once you give me a particular natural, there are a finite number of naturals between that number and zero. You won't be taking steps forever. The accessibility of every element (well founded-ness) ensures that.  

<div class="paragraph"> </div>

Enough talk, let's see it.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="divide"><span class="id" title="definition">divide</span></a> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
&nbsp;<span class="id" title="tactic">refine</span> <br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">Fix</span> <a class="idref" href="wellfounded.html#pairsWfr"><span class="id" title="lemma">pairsWfr</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">subcall</span> : <span class="id" title="keyword">forall</span>  <span class="id" title="var">p'</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>, <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <a class="idref" href="wellfounded.html#p'"><span class="id" title="variable">p'</span></a> <a class="idref" href="wellfounded.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="wellfounded.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <span class="id" title="var">n</span> 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <span class="id" title="var">n</span> <span class="id" title="var">d</span>  =&gt;  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Nat.html#leb"><span class="id" title="definition">Nat.leb</span></a> <span class="id" title="var">d</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="wellfounded.html#subcall"><span class="id" title="variable">subcall</span></a> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> (<span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">-</span></a><span class="id" title="var">d</span>) <span class="id" title="var">d</span>) <span class="id" title="var">_</span> )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> 0 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;). <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Crap.. You and I know that when I enter the prover to fill in the '_', it's impossible for d to be zero because of the previous match case. However Coq as of version 8.5pl2 has no idea this is the case. Instead we'll just have to encode the whole dang function body in the prover. 

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="divide_v2"><span class="id" title="definition">divide_v2</span></a> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
&nbsp;<span class="id" title="tactic">refine</span> <br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">Fix</span> <a class="idref" href="wellfounded.html#pairsWfr"><span class="id" title="lemma">pairsWfr</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">subcall</span> : <span class="id" title="keyword">forall</span>  <span class="id" title="var">p'</span> : <a class="idref" href="wellfounded.html#MyStupidPair"><span class="id" title="inductive">MyStupidPair</span></a>, <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a> <a class="idref" href="wellfounded.html#p'"><span class="id" title="variable">p'</span></a> <a class="idref" href="wellfounded.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;). <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> "divide by zero case".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> 0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> "S n0 case".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Nat.html#leb"><span class="id" title="definition">Nat.leb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n0</span>) <span class="id" title="var">n</span>) <span class="id" title="var">eqn</span> :<span class="id" title="tactic">case</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> "we can keep dividing!". <span class="id" title="tactic">refine</span>  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="var">subcall</span> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> (<span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">-</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n0</span><a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">)</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n0</span>))  <span class="id" title="var">_</span>) ).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="wellfounded.html#first_ltR"><span class="id" title="definition">first_ltR</span></a>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="tactic">case</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="tactic">case</span>. <span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">
Allow me to interupt. Our proof state is
<pre>
n, n0 : nat
subcall : forall p' : MyStupidPair, first_ltR p' (mystupidpair (S n) (S n0)) -&gt; nat
case : Nat.leb n0 n = true
______________________________________(1/2)
n - n0 &lt; S n
</pre>

<div class="paragraph"> </div>

You may be tempted to use some theorems from the standard library for this. Don't give in. Remember your function won't simplify if you use anything declared with <tt>Qed</tt> instead of <tt>Defined</tt>.  

<div class="paragraph"> </div>

NOTE: omega will solve this goal, but as of 8.5pl2 will cause Coqtop to "die badly" whenever you try to reduce your function.

<div class="paragraph"> </div>

We can solve this goal with some helpers easily enough. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="natsub"><span class="id" title="lemma">natsub</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>, <a class="idref" href="wellfounded.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">-</span></a> <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="wellfounded.html#n"><span class="id" title="variable">n</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="ltSucc"><span class="id" title="lemma">ltSucc</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="wellfounded.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="wellfounded.html#y"><span class="id" title="variable">y</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="wellfounded.html#ltSucc"><span class="id" title="lemma">ltSucc</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">IHn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="wellfounded.html#natsub"><span class="id" title="lemma">natsub</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> "we are done dividing, i.e. (S n0) is not less than n".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> 0. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
WE DID IT 
</div>
<div class="code">
<span class="id" title="keyword">Print</span> <a class="idref" href="wellfounded.html#divide_v2"><span class="id" title="definition">divide_v2</span></a>.<br/>

<br/>
</div>

<div class="doc">
THAT'S SO UGLY. And beautiful.
If I put the output here it would double the length of this post. 

<div class="paragraph"> </div>

I don't want to have to make a MyStupidPair every time I want to divide.

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="myDivide"><span class="id" title="definition">myDivide</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.5pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) := <a class="idref" href="wellfounded.html#divide_v2"><span class="id" title="definition">divide_v2</span></a> (<a class="idref" href="wellfounded.html#mystupidpair"><span class="id" title="constructor">mystupidpair</span></a> <a class="idref" href="wellfounded.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="wellfounded.html#y"><span class="id" title="variable">y</span></a>).<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a>.<br/>
</div>

<div class="doc">
<pre>
myDivide
     : nat -&gt; nat -&gt; nat
</pre>
It's beautiful. 

</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 0 0).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 3 4).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 4 2).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 5 2).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 100 7).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<a class="idref" href="wellfounded.html#myDivide"><span class="id" title="definition">myDivide</span></a> 3 4).<br/>

<br/>
</div>

<div class="doc">
The end 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>